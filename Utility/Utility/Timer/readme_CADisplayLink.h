############################################################################################
CADisplayLink
############################################################################################
简介：
一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器，精度比NSTimer要高。
适用场景为做UI的不停重绘（比如：自定义动画引擎、视频播放的渲染等）
案例参考CADisplayLinkTest

############################################################################################
使用方式
1)创建一个新的CADisplayLink对象
2)将它添加到runloop中
3)给它提供一个target和selector在屏幕刷新时调用

############################################################################################
每当屏幕需要刷新的时，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到CADisplayLink
的每次调用的时间戳，用来准备下一帧显示需要的数据。

在动画的过程中，runloop被添加进来一个高优先级的任务，下一次调用就会被暂停转而先执行高优先级的任务，然后再接着执行
CADisplayLink的调用，从而造成动画过程的卡顿。

############################################################################################
几个属性

duration
提供每帧之间的时间，即屏幕每次刷新之间的时间。
这只是个大概的时间，如果CPU忙于计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。

frameInterval
帧间隔次数，默认值为1，即每帧都调用一次。

pause
控制CADisplayLink的运行

invalidate
结束一个CADisplayLink，从runloop中删除之前绑定的target和selector

############################################################################################
注意

iOS设置的刷新频率为60HZ，则每一帧的刷新时间为1/60秒，约16.7ms
当frameInterval值为1的时候，CADisplayLink调用的target的方法计算时间不能大于16.7ms，否则会出现严重的丢帧现象。

在mac上使用的不是CADisplayLink，而是CVDisplayLink，基于C接口的

############################################################################################
NSTimer的精度问题

精度较低，比如NSTimer的触发时间到了，runloop如果处于阻塞状态，则触发时间就会推迟到下一个runloop周期。
NSTimer的tolerance属性，让用户可以设置可以容忍的触发时间的延迟范围。



